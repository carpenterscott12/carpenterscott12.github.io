<!DOCTYPE html>

<head>
    <link rel="stylesheet" type="text/css" href="shared.css" />
    <link rel="stylesheet" type="text/css" href="stadium.css" />
</head>

<body>
    <div id="MainMenu">
        <div>Main Menu</div>
        <div>Create or modify your teams of fighters:</div>
        <input type="button" value="Team 1" />
        <input type="button" value="Team 2" />
        <input type="button" value="Team 3" />
        <input type="button" value="Team 4" />
        <div>Choose the tournament to participate in:</div>
        <input type="button" value="Power" />
        <input type="button" value="Stat Changes" />
        <input type="button" value="Status Conditions" />
    </div>
    <div id="TeamEditor" style="display: none">
        <div id="TeamEditorFighterList">
            <div id="TeamEditorTeamNameContainer">
                <div>Team Name:</div>
                <input type="text" />
            </div>
            <div>
                <div id="Fighter1Name">Fighter 1</div>
                <input type="button" value="Edit" />
            </div>
            <div>
                <div id="Fighter1Name">Fighter 2</div>
                <input type="button" value="Edit" />
            </div>
            <div>
                <div id="Fighter1Name">Fighter 3</div>
                <input type="button" value="Edit" />
            </div>
            <div>
                <div id="Fighter1Name">Fighter 4</div>
                <input type="button" value="Edit" />
            </div>
            <div>
                <div id="Fighter1Name">Fighter 5</div>
                <input type="button" value="Edit" />
            </div>
            <div>
                <div id="Fighter1Name">Fighter 6</div>
                <input type="button" value="Edit" />
            </div>
            <div id="TeamEditorSaveAndCancelButtons">
                <input type="button" value="Save Changes" />
                <input type="button" value="Cancel Changes" />
            </div>
        </div>
        <div id="FighterEditor" style="display: none">
            <div>Select Move 1:</div>
            <select id="move1Select">
                <option value="1">Option 1</option>
                <option value="2">Option 2</option>
                <option value="3">Option 3</option>
            </select>
            <div>Select Move 2:</div>
            <select id="move2Select">
                <option value="1">Option 1</option>
                <option value="2">Option 2</option>
                <option value="3">Option 3</option>
            </select>
            <div>Select Move 3:</div>
            <select id="move3Select">
                <option value="1">Option 1</option>
                <option value="2">Option 2</option>
                <option value="3">Option 3</option>
            </select>
            <div id="FighterEditorSaveAndCancelButtons">
                <input type="button" value="Save Changes" />
                <input type="button" value="Cancel Changes" />
            </div>
        </div>
    </div>
    <div id="FightLayout" style="display: none">
        <div id="PrimaryFightLayout">
            <div id="EnemyFighterInfo">
                <img src="stadium/images/fighters/Tom.png" />
                <div>Enemy Fighter: </div>
                <div id="EnemyFighterName">EnemyFighterName</div>
            </div>
            <div>
                <div>HP</div>
                <div id="EnemyCurrentHP"></div>
                <div>/</div>
                <div id="EnemyMaximumHP"></div>
                <div id="EnemyPoisonedIndicator">*Poisoned*</div>
                <div id="EnemySlowedIndicator">*Slowed*</div>
            </div>

            <div id="PlayerFighterInfo">
                <img src="stadium/images/fighters/Matt.png" />
                <div>Your Fighter: </div>
                <div id="PlayerFighterName">PlayerFighterName</div>
            </div>
            <div>
                <div>HP</div>
                <div id="PlayerCurrentHP"></div>
                <div>/</div>
                <div id="PlayerMaximumHP"></div>
                <div id="PlayerPoisonedIndicator">*Poisoned*</div>
                <div id="PlayerSlowedIndicator">*Slowed*</div>
            </div>
            <input type="button" value="Move 1" />
            <input type="button" value="Move 2" />
            <input type="button" value="Move 3" />
            <input type="button" value="Swap Fighters" />
        </div>
        <div id="SwapFightersLayout" style="display: none">
            <div id="SwapFighter1Group">
                <img src="stadium/images/fighters/Matt.png" />
                <div id="SwapFighter1Name">Fighter 1</div>
                <input type="button" value="Select" />
            </div>
            <div id="SwapFighter2Group">
                <img src="stadium/images/fighters/Tom.png" />
                <div id="SwapFighter2Name">Fighter 2</div>
                <input type="button" value="Select" />
            </div>
            <div id="SwapFighter3Group">
                <img src="stadium/images/fighters/Ryan.png" />
                <div id="SwapFighter3Name">Fighter 3</div>
                <input type="button" value="Select" />
            </div>
            <div id="SwapFighter4Group">
                <img src="stadium/images/fighters/Baldoo.png" />
                <div id="SwapFighter4Name">Fighter 4</div>
                <input type="button" value="Select" />
            </div>
            <div id="SwapFighter5Group">
                <img src="stadium/images/fighters/Baldao.png" />
                <div id="SwapFighter5Name">Fighter 5</div>
                <input type="button" value="Select" />
            </div>
            <div id="SwapFighter6Group">
                <img src="stadium/images/fighters/Elderoo.png" />
                <div id="SwapFighter6Name">Fighter 6</div>
                <input type="button" value="Select" />
            </div>
        </div>
    </div>
</body>
<style>

</style>

<script>

    const types = ["rock", "paper", "scissors"];
    const damageCategories = ["a", "m"];
    const statusConditions = ["poison", "slowed"];
    const operators = ["add", "multiply"];
    const maxStatDelta = 6;
    const maxNumberOfMoves = 3;
    let currentPlayerFighterCurrentHp = new HtmlDiv("PlayerCurrentHP");
    let currentPlayerFighterMaxHp = new HtmlDiv("PlayerMaximumHP");
    let currentPlayerPoisonedIndicator = new HtmlDiv("PlayerPoisonedIndicator");
    let currentPlayerSlowedIndicator = new HtmlDiv("PlayerSlowedIndicator");
    let currentOpponentFighterCurrentHp = new HtmlDiv("EnemyCurrentHP");
    let currentOpponentFighterMaxHp = new HtmlDiv("EnemyMaximumHP");
    let currentOpponentPoisonedIndicator = new HtmlDiv("EnemyPoisonedIndicator");
    let currentOpponentSlowedIndicator = new HtmlDiv("EnemySlowedIndicator");
    let gameState = null;
    
    class GameState {
        constructor() {
            this._currentPlayerFighter = null; // Fighter object
            this._currentOpponentFighter = null; // Fighter object
            this._currentPlayerTeam = null; // Array of Fighter objects
            this._currentOpponentTeam = null; // Array of Fighter objects
        }

        setNewCurrentPlayerFighter(newFighter) {
            this.clearFighterHtmlElements(this._currentPlayerFighter);

            this._currentPlayerFighter = newFighter;

            this.setUpFighterHtmlElements(this._currentPlayerFighter, currentPlayerFighterCurrentHp, currentPlayerFighterMaxHp, currentPlayerPoisonedIndicator, currentPlayerSlowedIndicator);
        }

        setNewCurrentOpponentFighter(newFighter) {
            this.clearFighterHtmlElements(this._currentOpponentFighter);

            this._currentOpponentFighter = newFighter;

            this.setUpFighterHtmlElements(this._currentOpponentFighter, currentOpponentFighterCurrentHp, currentOpponentFighterMaxHp, currentOpponentPoisonedIndicator, currentOpponentSlowedIndicator);
        }

        clearFighterHtmlElements(fighter) {
            fighter._maxHpElement = null;
            fighter._currentHpElement = null;
            fighter._poisonedIndicator.hide();
            fighter._slowedIndicator.hide();
            fighter._poisonedIndicator = null;
            fighter._slowedIndicator = null;
        }

        setUpFighterHtmlElements(fighter, currentHpElement, maxHpElement, poisonedIndicator, slowedIndicator) {
            fighter._currentHpElement = currentHpElement;
            fighter._maxHpElement = maxHpElement;
            fighter._poisonedIndicator = poisonedIndicator;
            fighter._slowedIndicator = slowedIndicator;
            if (fighter._isPoisoned) {
                fighter._poisonedIndicator.showInlineBlock();
            }
            if (fighter._isSlowed) {
                fighter._slowedIndicator.showInlineBlock();
            }
        }
    }

    class Fighter {
        constructor(name, type, maxHp, attack, defense, magicAttack, magicDefense, speed, moves) {
            this._name = name;
            this._type = type;
            this._maxHp = maxHp;
            this._attack = attack;
            this._defense = defense;
            this._magicAttack = magicAttack;
            this._magicDefense = magicDefense;
            this._speed = speed;
            this._moves = moves;
            this._currentHp = this._maxHp;
            this._deltaAttack = 0;
            this._deltaDefense = 0;
            this._deltaMagicAttack = 0;
            this._deltaMagicDefense = 0;
            this._deltaSpeed = 0;
            this._isPoisoned = false;
            this._isSlowed = false;
            this._maxHpElement = null;
            this._currentHpElement = null;
            this._poisonedIndicator = null;
            this._slowedIndicator = null;
        }

        useMove(moveIndex, target) {
            if (moveIndex >= maxNumberOfMoves) {
                console.log("Error: move index out of bounds!");
            }
            else {
                let move = this._moves[moveIndex];
                if (move._affectedByAccuracy) {
                    if (move._accuracy < 100) {
                        let accuracyRoll = getRandomIntInclusive(1, 100);
                        if (accuracyRoll > move._accuracy) {
                            console.log("The move missed!");
                            // TODO: conclude the move usage
                            return;
                        }
                        else {
                            if (move._causesDamageDirectly) {
                                let damage = calculateDamageToSingleTarget(this, target, move);
                                target._currentHp -= damage;
                                if (target._currentHp < 0) {
                                    target._currentHp = 0;
                                }
                                if (target._currentHp == 0) {
                                    // TODO: Handle target being defeated
                                }
                            }
                            if (move._inflictsStatus) {
                                if (move._statusToInflict) {
                                    if (target.hasStatusCondition()) {
                                        // TODO: Show a message saying the target already has a status condition
                                    }
                                    else {
                                        if (move._statusToInflict == "poison") {
                                            target._isPoisoned = true;
                                            target._poisonedIndicator.showInlineBlock();
                                        }
                                        else if (move._statusToInflict == "slowed") {
                                            target._isSlowed = true;
                                            target._slowedIndicator.showInlineBlock();
                                        }
                                        else {
                                            console.log("The status to inflict was not 'poison' or 'slowed'. No status was applied to the target fighter.");
                                        }
                                    }
                                }
                                else {
                                    console.log("Error: the move tried to inflict status, but statusToInflict was null or undefined.");
                                }
                            }
                            if (move._changesStatsOfSelf) {
                                this.changeStats(move._statChanges);
                            }
                            if (move._changesStatsOfTarget) {
                                target.changeStats(move._statChanges);
                            }
                        }
                    }
                }
                else {
                    if (move._causesDamageDirectly) {
                        // TODO: damage calcs
                    }
                }
            }
        }

        changeStats(statChanges) {
            // It's okay to assume that HP is truthy if it needs to be applied. If it is 0, then there is no change to apply.
            if (statChanges._hp) {
                // TODO: Calculate HP change
                if (this._currentHp == this._maxHp && statChanges._hp > 0) {
                    // TODO: Say that hp was already at maximum
                }
                else {
                    let oldHpValue = this._currentHp.valueOf();
                    this._currentHp += statChanges._hp;
                    if (this._currentHp <= this._maxHp && statChanges._hp > 0) {
                        // TODO: Say that we healed HP equal to move_statChanges._hp
                    }
                    else if (this._currentHp <= 0) {
                        // TODO: Show that this fighter has been defeated
                    }
                    else {
                        let hpChange = this._currentHp - oldHpValue;
                    }
                }
            }
            if (statChanges._attack) {
                this._deltaAttack = this.changeStat(statChanges._attack, this._deltaAttack, "attack");
            }
            if (statChanges._defense) {
                this._deltaDefense = this.changeStat(statChanges._defense, this._deltaDefense, "defense");
            }
            if (statChanges._magicAttack) {
                this._deltaMagicAttack = this.changeStat(statChanges._magicAttack, this._deltaMagicAttack, "magic attack");
            }
            if (statChanges._magicDefense) {
                this._deltaMagicDefense = this.changeStat(statChanges._magicDefense, this._deltaMagicDefense, "magic defense");
            }
            if (statChanges._speed) {
                this._deltaSpeed = this.changeStat(statChanges._speed, this._deltaSpeed, "speed");
            }
        }

        changeStat(statChange, deltaStat, statName) {
            if (statChange > 0) {
                if (deltaStat >= maxStatDelta) {
                    // TODO: Show that this stat cannot go higher
                }
                else if (Math.abs(deltaStat) >= maxStatDelta) {
                    // TODO: Show that this stat cannot go lower
                }
                else {
                    let oldStatValue = deltaStat;
                    deltaStat += statChange;
                    if (deltaStat > maxStatDelta) {
                        let statChange = maxStatDelta - oldStatValue;
                        // TODO: Show that this stat was increased by statChange
                    }
                    else if (Math.abs(deltaStat) > maxStatDelta) {
                        let statChange = maxStatDelta - Math.abs(deltaStat);
                        // TODO: Show that this stat was decreased by statChange
                    }
                    else {
                        if (statChange > 0) {
                            // TODO: Show that this stat was increased by statChange
                        }
                        else {
                            // TODO: Show that this stat was decreased by Math.abs(statChange)
                        }
                    }
                }
            }
            return deltaStat;
        }

        hasStatusCondition() {
            if (this._isSlowed || this._isPoisoned) {
                return true;
            }
            else {
                return false;
            }
        }
    }

    class FighterMove {
        constructor(name, type, damageCategory, power, accuracy, affectedByAccuracy, causesDamageDirectly, inflictsStatus,
            chanceToInflictStatus, statusToInflict, changesStatsOfSelf, halvesDamageToSelfOnNextHit, changesStatsOfTarget, statChanges) {
            this._name = name;
            this._type = type;
            this._damageCategory = damageCategory;
            this._power = power;
            this._accuracy = accuracy;
            this._affectedByAccuracy = affectedByAccuracy;
            this._causesDamageDirectly = causesDamageDirectly;
            this._inflictsStatus = inflictsStatus;
            this._chanceToInflictStatus = chanceToInflictStatus;
            this._statusToInflict = statusToInflict;
            this._changesStatsOfSelf = changesStatsOfSelf;
            this._halvesDamageToSelfOnNextHit = halvesDamageToSelfOnNextHit;
            this._changesStatsOfTarget = changesStatsOfTarget;
            this._statChanges = statChanges;
        }
    }

    class StatChanges {
        constructor(hp, attack, defense, magicAttack, magicDefense, speed) {
            this._hp = hp; // Integer, can be any size and can be positive or negative
            this._attack = attack; // Integer, can be positive or negative, but absolute value cannot exceed the value of maxStatDelta
            this._defense = defense;
            this._magicAttack = magicAttack;
            this._magicDefense = magicDefense;
            this._speed = speed;
        }
    }

    class Player {
        constructor(name) {
            this._name = name;
        }
    }

    class HtmlDiv {
        constructor(divId, defaultInnerHtml) {
            this._divId = divId;
            this._element = document.getElementById(divId);
            // Make defaultInnerHtml optional param
            if (defaultInnerHtml !== undefined) {
                this._element.innerHTML = defaultInnerHtml;
            }
        }

        hide() {
            this._element.style.display = "none";
        }

        showBlock() {
            this._element.style.display = "block";
        }

        showInlineBlock() {
            this._element.style.display = "inline-block";
        }

        setInnerHtml(input) {
            this._element.innerHTML = input;
        }

        setColorRed() {
            this._element.style.color = "red";
        }

        setColorBlack() {
            this._element.style.color = "black";
        }

        setColorGreen() {
            this._element.style.color = "#03DAC6";
        }

        setColorWhite() {
            this._element.style.color = "#FFFFFF";
        }

        setClassName(inputClassName) {
            this._element.className = inputClassName;
        }
    }

    function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function calculateDamageToSingleTarget(attacker, defender, move) {
        let attackOverDefense = null;

        if (move._damageCategory == "a") {
            attackOverDefense = (attacker._attack * attacker._deltaAttack) / (defender._defense * defender._deltaDefense);
        }
        else if (move._damageCategory == "m") {
            attackOverDefense = (attacker._magicAttack * attacker._deltaMagicAttack) / (defender._magicDefense * defender._deltaMagicDefense);
        }
        else {
            console.log("The move's damage category was invalid");
        }

        let typeResistanceMultiplier = getTypeResistanceMultiplier(move._type, defender._type);
        let sameTypeAttackBonus = 1;
        if (attacker._type == move._type) {
            sameTypeAttackBonus = 1.5;
        }

        let randomValue = getRandomIntInclusive(85, 100) * 0.01;

        let damage = attackOverDefense * move._power * sameTypeAttackBonus * randomValue * typeResistanceMultiplier;
        if (damage < 1) {
            return 1;
        }
        else {
            return Math.round(damage);
        }
    }

    function getTypeResistanceMultiplier(attackingMoveType, defenderType) {
        if (attackingMoveType == defenderType) {
            return 1;
        }
        if (attackingMoveType == "rock") {
            if (defenderType == "paper") {
                return 0.5;
            }
            else if (defenderType == "scissors") {
                return 2;
            }
            else {
                console.log("Invalid type for defender");
            }
        }
        else if (attackingMoveType == "paper") {
            if (defenderType == "scissors") {
                return 0.5;
            }
            else if (defenderType == "rock") {
                return 2;
            }
            else {
                console.log("Invalid type for defender");
            }
        }
        else if (attackingMoveType == "scissors") {
            if (defenderType == "rock") {
                return 0.5;
            }
            else if (defenderType == "paper") {
                return 2;
            }
            else {
                console.log("Invalid type for defender");
            }
        }
        else {
            console.log("Invalid type for attacker");
        }
    }

    function statCannotIncreaseFurther(statChange, currentStatValue, maxStat) {
        if (statChange <= 0) {
            return false;
        }
        else {
            if (Math.abs(statChange + currentStatValue) > maxStat) {
                return true;
            }
            else {
                return false;
            }
        }
    }

    function statCannotDecreaseFurther(statChange, currentStatValue, maxStat) {
        if (statChange >= 0) {
            return false;
        }
        else {
            if (Math.abs(currentStatValue - statChange) > maxStat) {
                return true;
            }
            else {
                return false;
            }
        }
    }

    function startGame() {
        gameState = new GameState();
        let move_heavyPunch = new FighterMove("Heavy Punch", "rock", "a", 90, 100, true, true, false, false, null, false, false, false, null);
        let move_poisonBlade = new FighterMove("Poison Blade", "scissors", "a", 70, 100, true, true, false, true, "poison", false, false, false, null);
        let fighter_kyle = new Fighter("Kyle Blastar", "rock", 100, 120, 80, 100, 120, 80, [move_heavyPunch]);
        console.log(fighter_kyle);
        let fighter_matt = new Fighter("Matt", "scissors", 100, 100, 100, 100, 100, 100, [move_poisonBlade]);
        console.log(fighter_matt);
        gameState._currentPlayerTeam = [fighter_kyle];
        gameState._currentOpponentTeam = [fighter_matt];
        gameState._currentPlayerFighter = fighter_kyle;
        gameState._currentOpponentFighter = fighter_matt;
        console.log(gameState);
    }


    // Main game:
    startGame();


</script>

</html>