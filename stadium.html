<!DOCTYPE html>

<head>
    <link rel="stylesheet" type="text/css" href="shared.css" />
    <link rel="stylesheet" type="text/css" href="stadium.css" />
</head>

<body>
    
</body>
<style>

</style>

<script>

    const types = ["rock", "paper", "scissors"];
    const damageCategories = ["a", "m"];
    const statusConditions = ["poison", "slowed"];
    const operators = ["add", "multiply"];
    const maxStatDelta = 6;
    const maxNumberOfMoves = 3;

    class Fighter {
        constructor(name, type, maxHp, attack, defense, magicAttack, magicDefense, speed, moves) {
            this._name = name;
            this._type = type;
            this._maxHp = maxHp;
            this._attack = attack;
            this._defense = defense;
            this._magicAttack = magicAttack;
            this._magicDefense = magicDefense;
            this._speed = speed;
            this._moves = moves;
            this._currentHp = this._maxHp;
            this._deltaAttack = 0;
            this._deltaDefense = 0;
            this._deltaMagicAttack = 0;
            this._deltaMagicDefense = 0;
            this._deltaSpeed = 0;
            this._isPoisoned = false;
            this._isSlowed = false;
        }
        
        useMove(moveIndex, target) {
            if (moveIndex >= maxNumberOfMoves) {
                console.log("Error: move index out of bounds!");
            }
            else {
                let move = this._moves[moveIndex];
                if (move._affectedByAccuracy) {
                    if (move._accuracy < 100) {
                        let accuracyRoll = getRandomIntInclusive(1, 100);
                        if (accuracyRoll > move._accuracy) {
                            console.log("The move missed!");
                            // TODO: conclude the move usage
                            return;
                        }
                        else {
                            if (move._causesDamageDirectly) {
                                // TODO: damage calcs
                                if (move._targetsSelf) {
                                    // TODO: Damage self
                                }
                                else if (move._targetsBothOpponents) {
                                    // TODO: Damage both opponents
                                }
                                else if (move._targetsAllOtherFighters) {
                                    // TODO: Damage all other fighters
                                }
                                else {
                                    // TODO: Damage the selected target
                                    let damage = calculateDamageToSingleTarget(this, target, move);
                                }
                            }
                            else if (move._inflictsStatus) {
                                if (move._statusToInflict) {
                                    if (move._targetsSelf) {
                                        // TODO: Inflict status on self
                                    }
                                    else if (move._targetsBothOpponents) {
                                        // TODO: Inflict status on both opponents
                                    }
                                    else if (move._targetsAllOtherFighters) {
                                        // TODO: Inflict status on all other fighters
                                    }
                                    else {
                                        // TODO: Inflict status on the selected target
                                        if (hasStatusCondition(target)) {
                                            // TODO: Show a message saying the target already has a status condition
                                        }
                                        else {
                                            if (move._statusToInflict == "poison") {
                                                target._isPoisoned = true;
                                            }
                                            else if (move._statusToInflict == "slowed") {
                                                target._isSlowed = true;
                                            }
                                            else {
                                                console.log("The status to inflict was not 'poison' or 'slowed'. No status was applied to the target fighter.");
                                            }
                                        }
                                    }
                                }
                                else {
                                    console.log("Error: the move tried to inflict status, but statusToInflict was null or undefined");
                                }
                            }
                            else if (move._changesStatsWhenUsed) {
                                // It's okay to assume that HP is truthy if it needs to be applied. If it is 0, then there is no change to apply.
                                if (move._statChanges._hp) {
                                    // TODO: Calculate HP change
                                }
                                if (move._statChanges._attack) {
                                    // TODO: Calculate attack change
                                }
                                if (move._statChanges._defense) {
                                    // TODO: Calculate defense change
                                }
                                if (move._statChanges._magicAttack) {
                                    // TODO: Calculate magicAttack change
                                }
                                if (move._statChanges._magicDefense) {
                                    // TODO: Calculate magicDefense change
                                }
                                if (move._statChanges._speed) {
                                    // TODO: Calculate speed change
                                }
                            }
                        }
                    }
                }
                else {
                    if (move._causesDamageDirectly) {
                        // TODO: damage calcs
                    }
                }
            }
        }
    }

    class FighterMove {
        constructor(name, type, damageCategory, power, accuracy, affectedByAccuracy, causesDamageDirectly, inflictsStatus, 
            chanceToInflictStatus, statusToInflict, targetsSelf, targetsBothOpponents, targetsAllOtherFighters, changesStatsWhenUsed, halvesDamageToSelfOnNextHit,
            changeStatsOnNextHit, statChanges) {
            this._name = name;
            this._type = type;
            this._damageCategory = damageCategory;
            this._power = power;
            this._accuracy = accuracy;
            this._affectedByAccuracy = affectedByAccuracy;
            this._causesDamageDirectly = causesDamageDirectly;
            this._inflictsStatus = inflictsStatus;
            this._chanceToInflictStatus = chanceToInflictStatus;
            this._statusToInflict = statusToInflict;
            this._targetsSelf = targetsSelf;
            this._targetsBothOpponents = targetsBothOpponents;
            this._targetsAllOtherFighters = targetsAllOtherFighters;
            this._changesStatsWhenUsed = changesStatsWhenUsed;
            this._halvesDamageToSelfOnNextHit = halvesDamageToSelfOnNextHit;
            this._changeStatsOnNextHit = changeStatsOnNextHit;
            this._statChanges = statChanges;
        }

        resolveTargets() {
            let targets = [];
            if (this._targetsSelf) {
                // TODO: Inflict status on self
            }
            else if (this._targetsBothOpponents) {
                // TODO: Inflict status on both opponents
            }
            else if (this._targetsAllOtherFighters) {
                // TODO: Inflict status on all other fighters
            }
            else {
                // TODO: Inflict status on the selected target
            }
        }
    }

    class StatChanges {
        constructor(hp, attack, defense, magicAttack, magicDefense, speed) {
            this._hp = hp; // Integer, can be any size and can be positive or negative
            this._attack = attack; // Integer, can be positive or negative, but absolute value cannot exceed the value of maxStatDelta
            this._defense = defense;
            this._magicAttack = magicAttack;
            this._magicDefense = magicDefense;
            this._speed = speed;
        }
    }

    class Player {
        constructor(name) {
            this._name = name;
        }
    }

    function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function calculateDamageToSingleTarget(attacker, defender, move) {
        let attackOverDefense = null;
        
        if (move._damageCategory == "a") {
            attackOverDefense = (attacker._attack * attacker._deltaAttack) / (defender._defense * defender._deltaDefense);
        }
        else if (move._damageCategory == "m") {
            attackOverDefense = (attacker._magicAttack * attacker._deltaMagicAttack) / (defender._magicDefense * defender._deltaMagicDefense);
        }
        else {
            console.log("The move's damage category was invalid");
        }

        let typeResistanceMultiplier = getTypeResistanceMultiplier(move._type, defender._type);
        let sameTypeAttackBonus = 1;
        if (attacker._type == move._type) {
            sameTypeAttackBonus = 1.5;
        }

        let randomValue = getRandomIntInclusive(85, 100) * 0.01;

        let damage = attackOverDefense * move._power * sameTypeAttackBonus * randomValue * typeResistanceMultiplier;
        if (damage < 1) {
            return 1;
        }
        else {
            return Math.round(damage);
        }
    }

    function getTypeResistanceMultiplier(attackingMoveType, defenderType) {
        if (attackingMoveType == defenderType) {
            return 1;
        }
        if (attackingMoveType == "rock") {
            if (defenderType == "paper") {
                return 0.5;
            }
            else if (defenderType == "scissors") {
                return 2;
            }
            else {
                console.log("Invalid type for defender");
            }
        }
        else if (attackingMoveType == "paper") {
            if (defenderType == "scissors") {
                return 0.5;
            }
            else if (defenderType == "rock") {
                return 2;
            }
            else {
                console.log("Invalid type for defender");
            }
        }
        else if (attackingMoveType == "scissors") {
            if (defenderType == "rock") {
                return 0.5;
            }
            else if (defenderType == "paper") {
                return 2;
            }
            else {
                console.log("Invalid type for defender");
            }
        }
        else {
            console.log("Invalid type for attacker");
        }
    }

    function hasStatusCondition(fighter) {
        if (fighter._isSlowed || fighter._isPoisoned) {
            return true;
        }
        else {
            return false;
        }
    }

    function statCannotIncreaseFurther(statChange, currentStatValue, maxStat) {
        if (statChange <= 0) {
            return false;
        }
        else {
            if (Math.abs(statChange + currentStatValue) > maxStat) {
                return true;
            }
            else {
                return false;
            }
        }
    }

    function statCannotDecreaseFurther(statChange, currentStatValue, maxStat) {
        if (statChange >= 0) {
            return false;
        }
        else {
            if (Math.abs(currentStatValue - statChange) > maxStat) {
                return true;
            }
            else {
                return false;
            }
        }
    }

    function startGame() {
        let move_heavyPunch = new FighterMove("Heavy Punch", "rock", "a", 90, 100, true, true, false, false, null, false, false, false, false, false, false, null);
        let move_poisonBlade = new FighterMove("Poison Blade", "scissors", "a", 70, 100, true, true, false, true, "poison", false, false, false, false, false, false, null);
        let fighter_kyle = new Fighter("Kyle Blastar", "rock", 100, 120, 80, 100, 120, 80, [move_heavyPunch]);
        console.log(fighter_kyle);
        let fighter_matt = new Fighter("Matt", "scissors", 100, 100, 100, 100, 100, 100, [move_poisonBlade]);
        console.log(fighter_matt);
    }


    // Main game:
    startGame();


</script>

</html>