<!DOCTYPE html>

<head>
    <link rel="stylesheet" type="text/css" href="shared.css" />
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <link rel="stylesheet" type="text/css" href="spades.css" />
</head>

<body>

    <div id="GameContainer">
        <div id="ScoreArea">
            <div id="Team1NameAndScore"><div id="Team1Name">Team 1 (Player1 and COM3)</div><div id="Team1Score">0</div></div>
            <div id="Team2NameAndScore"><div id="Team2Name">Team 2 (COM2 and COM4)</div><div id="Team2Score">0</div></div>
        </div>
        <div id="PlayArea">
            <div id="Player3Data">
                <div id="Player3Card" class="play-area-card"></div>
                <div id="Player3Name" class="data-text">COM3</div>
                <div id="Player3TricksToBids" class="data-text">
                    <div id="Player3Tricks" class="data-text">-</div>/<div id="Player3Bid" class="data-text">-</div>
                </div>
            </div>
            <div id="WestAndEastCardContainer">
                <div id="Player2Data">
                    <div id="Player2Card" class="play-area-card"></div>
                    <div id="Player2Name" class="data-text">COM2</div>
                    <div id="Player2TricksToBids" class="data-text">
                        <div id="Player2Tricks" class="data-text">-</div>/<div id="Player2Bid" class="data-text">-</div>
                    </div>
                </div>
                <div id="Player4Data">
                    <div id="Player4Card" class="play-area-card"></div>
                    <div id="Player4Name" class="data-text">COM4</div>
                    <div id="Player4TricksToBids" class="data-text">
                        <div id="Player4Tricks" class="data-text">-</div>/<div id="Player4Bid" class="data-text">-</div>
                    </div>
                </div>
            </div>
            <div id="Player1Data">
                <div id="Player1Card" class="play-area-card"></div>
                <div id="Player1Name" class="data-text">Player1</div>
                <div id="Player1TricksToBids" class="data-text">
                    <div id="Player1Tricks" class="data-text">-</div>/<div id="Player1Bid" class="data-text">-</div>
                </div>
            </div>
        </div>
        <div id="PlayerCardsContainer">
            <input id="playerCard0" class="player-card" type="button" />
            <input id="playerCard1" class="player-card" type="button" />
            <input id="playerCard2" class="player-card" type="button" />
            <input id="playerCard3" class="player-card" type="button" />
            <input id="playerCard4" class="player-card" type="button" />
            <input id="playerCard5" class="player-card" type="button" />
            <input id="playerCard6" class="player-card" type="button" />
            <input id="playerCard7" class="player-card" type="button" />
            <input id="playerCard8" class="player-card" type="button" />
            <input id="playerCard9" class="player-card" type="button" />
            <input id="playerCard10" class="player-card" type="button" />
            <input id="playerCard11" class="player-card" type="button" />
            <input id="playerCard12" class="player-card" type="button" />
        </div>
        <div id="PlayerBidContainer">
            <div id="BidLabel">Bid:</div>
            <input id="PlayerBidInput" type="text" />
            <input id="PlayerBidSubmit" type="button" value="Submit" />
        </div>
    </div>

</body>
<style>

</style>

<script>

    // Globals
    let deck = null;
    let player1 = null;
    let player2 = null;
    let player3 = null;
    let player4 = null;
    let Player1CardDiv = null;
    let Player2CardDiv = null;
    let Player3CardDiv = null;
    let Player4CardDiv = null;
    let PlayerBidInput = null;
    let PlayerBidContainerDiv = null;
    let Team1ScoreDiv = null;
    let Team2ScoreDiv = null;
    let dealerIndex = null;
    let players = [];
    let currentBidCount = 0; // Once this is higher than 3, bidding is no longer active
    let currentPlayerTurn = null;
    let currentPlayedCards = [null, null, null, null];
    let cardsPlayedThisRound = 0;
    let spadesBrokenThisGame = false;
    let currentRoundSuit = null;
    let highestCurrentRoundCard = null;
    let Player1CardsWithInputs = [];
    let totalHandsPlayed = 0;
    let Player1AndPlayer3Score = 0;
    let Player2AndPlayer4Score = 0;
    let Player1AndPlayer3Sandbags = 0;
    let Player2AndPlayer4Sandbags = 0;

    // There should not be a reason to access index 0 or 1, but other indices correspond to card ranks in order of strength.
    const rankStrings = ["", "", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];

    const suitStrings = ["♠", "♥", "♣", "♦"];

    // Enums
    const Suit = {
        Spade: 0,
        Heart: 1,
        Club: 2,
        Diamond: 3
    }

    // Classes
    class HtmlDiv {
        constructor(divId, defaultInnerHtml) {
            this._divId = divId;
            this._element = document.getElementById(divId);
            // Make defaultInnerHtml optional param
            if (defaultInnerHtml !== undefined) {
                this._element.innerHTML = defaultInnerHtml;
            }
        }

        hide() {
            this._element.style.display = "none";
        }

        showBlock() {
            this._element.style.display = "block";
        }

        showInlineBlock() {
            this._element.style.display = "inline-block";
        }

        setInnerHtml(input) {
            this._element.innerHTML = input;
        }

        setColorRed() {
            this._element.style.color = "red";
        }

        setColorBlack() {
            this._element.style.color = "black";
        }

        setColorGreen() {
            this._element.style.color = "#03DAC6";
        }

        setColorWhite() {
            this._element.style.color = "#FFFFFF";
        }
    }

    class HtmlInput {
        constructor(inputId, val) {
            this._inputId = inputId;
            this._element = document.getElementById(inputId);
            // Make val optional param
            if (val !== undefined) {
                this._element.value = val;
            }
        }

        hide() {
            this._element.style.display = "none";
        }

        showBlock() {
            this._element.style.display = "block";
        }

        showInlineBlock() {
            this._element.style.display = "inline-block";
        }

        getValue() {
            return this._element.value;
        }

        setValue(val) {
            this._element.value = val;
        }

        setColorRed() {
            this._element.style.color = "red";
        }

        setColorBlack() {
            this._element.style.color = "black";
        }
    }

    class CardWithHtmlInput {
        constructor(card, htmlInput) {
            this._card = card;
            this._htmlInput = htmlInput;
            this._htmlInput.showInlineBlock();
        }
    }

    class Card {
        constructor(rank, suit) {
            this._rank = rank;
            this._suit = suit;
        }

        getString() {
            return rankStrings[this._rank] + suitStrings[this._suit];
        }

        isRed() {
            return (this._suit === Suit.Heart || this._suit === Suit.Diamond);
        }

        isBlack() {
            return (this._suit === Suit.Spade || this._suit === Suit.Club);
        }
    }

    class Deck {
        constructor() {
            this._cards = [];
            this.addAllRanksForSuit(Suit.Spade);
            this.addAllRanksForSuit(Suit.Heart);
            this.addAllRanksForSuit(Suit.Diamond);
            this.addAllRanksForSuit(Suit.Club);
            this.shuffle();
        }

        addAllRanksForSuit(suit) {
            let i = 0;
            for (i = 0; i < 13; i++) {
                let newCard = new Card(i + 2, suit);
                this._cards.push(newCard);
            }
        }

        shuffle() {
            for (let i = this._cards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this._cards[i], this._cards[j]] = [this._cards[j], this._cards[i]];
            }
        }

        draw() {
            if (this._cards.length > 0) {
                return this._cards.shift();
            }
            else {
                console.log("Deck was empty when trying to draw.");
                return null;
            }
        }
    }

    class Player {
        constructor(name, isHuman, playerPrefix) {
            this._name = name;
            this._isHuman = isHuman;
            this._cards = [[], [], [], []]; // One empty array per suit
            this._bid = null;
            this._tricksTaken = 0;
            this._playAreaDiv = new HtmlDiv(playerPrefix + "Card");
            this._dataDiv = new HtmlDiv(playerPrefix + "Data");
            this._nameDiv = new HtmlDiv(playerPrefix + "Name");
            this._tricksToBidsDiv = new HtmlDiv(playerPrefix + "TricksToBids");
            this._tricksDiv = new HtmlDiv(playerPrefix + "Tricks");
            this._bidDiv = new HtmlDiv(playerPrefix + "Bid");
        }

        addToHand(card) {
            this._cards[card._suit].push(card);
        }

        drawFullHand() {
            if (deck !== null && deck._cards.length >= 13) {
                let i = 0;
                for (i = 0; i < 13; i++) {
                    this.addToHand(deck.draw());
                }
                this.sortByRank(this._cards[Suit.Spade]);
                this.sortByRank(this._cards[Suit.Heart]);
                this.sortByRank(this._cards[Suit.Club]);
                this.sortByRank(this._cards[Suit.Diamond]);
            }
            else {
                console.log("The deck contained less than 13 cards when trying to deal a full hand.");
            }
        }

        updatePlayArea(card) {
            this._playAreaDiv.setInnerHtml(card.getString());
            if (card.isRed()) {
                this._playAreaDiv.setColorRed();
            }
            else if (card.isBlack()) {
                this._playAreaDiv.setColorBlack();
            }
        }

        incrementTricks() {
            this._tricksTaken++;
            this._tricksDiv.setInnerHtml(this._tricksTaken);
        }

        resetBidAndTricks() {
            this._cards = [[], [], [], []]; // One empty array per suit
            this._tricksTaken = 0;
            this._bid = null;
            this._tricksDiv.setInnerHtml("-");
            this._bidDiv.setInnerHtml("-");
        }

        removeCardFromHandIfExists(card) {
            if (this._cards[card._suit].length > 0) {
                let cardIndex = this._cards[card._suit].findIndex(findCard => findCard._rank === card._rank && findCard._suit === card._suit);
                if (cardIndex > -1) {
                    this._cards[card._suit].splice(cardIndex, 1);
                }
            }
        }

        getHandArray() {
            this._handArray = this._cards[Suit.Heart].concat(this._cards[Suit.Club].concat(this._cards[Suit.Diamond].concat(this._cards[Suit.Spade])));
            return this._handArray;
        }

        async playCard(card) {
            this.removeCardFromHandIfExists(card);
            cardsPlayedThisRound++;
            if (spadesBrokenThisGame === false && card._suit === Suit.Spade) {
                spadesBrokenThisGame = true;
            }
            currentPlayedCards[currentPlayerTurn] = card;

            console.log("Player " + this._name + " played: " + card.getString());
            this.updatePlayArea(card);

            if (highestCurrentRoundCard !== null) {
                if (card._suit === Suit.Spade) {
                    if (highestCurrentRoundCard._suit !== Suit.Spade) {
                        highestCurrentRoundCard = card;
                    }
                    else {
                        if (card._rank > highestCurrentRoundCard._rank) {
                            highestCurrentRoundCard = card;
                        }
                    }
                }
                else {
                    if (card._suit === currentRoundSuit) {
                        if (card._rank > highestCurrentRoundCard._rank && highestCurrentRoundCard._suit !== Suit.Spade) {
                            highestCurrentRoundCard = card;
                        }
                    }
                }
            }
            else {
                highestCurrentRoundCard = card;
                currentRoundSuit = card._suit;
            }

            if (cardsPlayedThisRound === 4) {
                // Set score and reset round state
                cardsPlayedThisRound = 0;
                let winnerIndex = null;
                let i = 0;
                for (i = 0; i < currentPlayedCards.length; i++) {
                    if (highestCurrentRoundCard._suit === currentPlayedCards[i]._suit && highestCurrentRoundCard._rank === currentPlayedCards[i]._rank) {
                        winnerIndex = i;
                    }
                    // if (winnerIndex === null) {
                    //     winnerIndex = i;
                    // }
                    // else {
                    //     let currentCard = currentPlayedCards[i];
                    //     let winnerCard = currentPlayedCards[winnerIndex];
                    //     // If suits are the same, take the higher rank.
                    //     if (currentCard._suit === winnerCard._suit) {
                    //         if (currentCard._rank > winnerCard._rank) {
                    //             winnerIndex = i;
                    //         }
                    //     }
                    //     else if (currentCard._suit === Suit.Spade) {
                    //         // If suit is spade, this wins because the current winner is not a spade.
                    //         winnerIndex = i;
                    //     }
                    //     else if (currentCard._suit === currentRoundSuit) {
                    //         // If the suit is the current round's suit to follow, this wins because the current winner is neither a spade nor the suit to follow.
                    //         winnerIndex = i;
                    //     }
                    //     else {
                    //         // This case means neither this card nor the current winner are the current suit to follow or spades, so it doesn't matter if I set winnerIndex to i here.
                    //         winnerIndex = i;
                    //     }
                    // }
                }

                players[winnerIndex].incrementTricks();
                //TODO: Indicate player's trick count vs bid count in the UI

                currentPlayedCards = [null, null, null, null];
                highestCurrentRoundCard = null;
                currentRoundSuit = null;
                await sleep(1000);
                clearPlayAreaCards();


                totalHandsPlayed++;
                if (totalHandsPlayed === 13) {
                    tallyCurrentRoundScore();
                    startNewRound();
                }

                setCurrentPlayerTurn(winnerIndex);
                let newRoundPlayer = players[currentPlayerTurn];

                console.log(player1);
                console.log(player2);
                console.log(player3);
                console.log(player4);

                if (!newRoundPlayer._isHuman) {
                    if (newRoundPlayer._cards[1].length === 0) {
                        console.log("Hearts suit has zero cards.");
                    }
                    await sleep(500);
                    await newRoundPlayer.playCard(newRoundPlayer.findCardToPlay());
                    return;
                }
                else {
                    return;
                }
            }

            nextTurn();
            let nextPlayer = players[currentPlayerTurn];
            if (nextPlayer._isHuman === false) {
                await sleep(500);
                await nextPlayer.playCard(nextPlayer.findCardToPlay());
            }
            return;
        }

        findCardToPlay() {
            // TODO: Remember to handle nil bid
            if (cardsPlayedThisRound === 0) {
                // Just pick a valid card
                if (spadesBrokenThisGame) {
                    // Consider spades as a lead suit
                    let nonSpadeAce = this.getNonSpadeAce();
                    if (nonSpadeAce !== null) {
                        return nonSpadeAce;
                    }
                    let highestSpade = this.getHighestAvailableSpade();
                    if (highestSpade !== null) {
                        return highestSpade;
                    }
                    else {
                        let lowestSpade = this.getLowestSpade();
                        if (lowestSpade !== null) {
                            return lowestSpade;
                        }
                        let lowestCardAvailable = this.getLowestAvailableCard();
                        if (lowestCardAvailable !== null) {
                            return lowestCardAvailable;
                        }
                        else {
                            console.log("Error: Lowest card available was null.");
                        }
                    }
                }
                else {
                    // Only consider hearts, clubs, and diamonds as lead suits
                    let highestNonSpade = this.getHighestAvailableCardNoSpades();
                    if (highestNonSpade !== null) {
                        return highestNonSpade;
                    }
                    let lowest = this.getLowestAvailableCardNotASpade();
                    if (lowest !== null) {
                        return lowest;
                    }
                    else {
                        let lowestSpade = this.getLowestSpade();
                        if (lowestSpade !== null) {
                            return lowestSpade;
                        }
                        else {
                            console.log("Error: Lowest spade was null.");
                        }
                    }
                }
            }
            else {
                // Follow suit if possible and play a card that will either win or minimize loss in value
                if (this._cards[currentRoundSuit].length > 0) {
                    let followSuitCard = this.getCardThatBeatsOrGoesLow();
                    if (followSuitCard !== null) {
                        return followSuitCard;
                    }
                    else {
                        if (this._tricksTaken < this._bid) {
                            let lowestSpade = this.getLowestSpade();
                            if (lowestSpade !== null) {
                                return lowestSpade;
                            }
                            else {
                                let lowestAvailable = this.getLowestAvailableCard();
                                if (lowestAvailable !== null) {
                                    return lowestAvailable;
                                }
                                else {
                                    console.log("Error: This lowest available was null.");
                                }
                            }
                        }
                        else {
                            let lowestCard = this.getLowestAvailableCard();
                            if (lowestCard !== null) {
                                return lowestCard;
                            }
                            else {
                                console.log("Error: The lowest available card was null.");
                            }
                        }
                    }
                }
                else {
                    // You can either play a spade or throw off a bad card from another suit
                    if (this._tricksTaken < this._bid) {
                        let lowestSpade = this.getLowestSpade();
                        if (lowestSpade !== null) {
                            return lowestSpade;
                        }
                        else {
                            let lowestAvailableCard = this.getLowestAvailableCard();
                            if (lowestAvailableCard !== null) {
                                return lowestAvailableCard;
                            }
                            else {
                                console.log("Error: That lowest available card was null.");
                            }
                        }
                    }
                    else {
                        let lowestAvailCard = this.getLowestAvailableCard();
                        if (lowestAvailCard !== null) {
                            return lowestAvailCard;
                        }
                        else {
                            console.log("Error: The lowest avail card was null.");
                        }
                    }
                }
            }
        }

        getNonSpadeAce() {
            let i = 1;
            for (i = 1; i < this._cards.length; i++) {
                if (this.containsAnAce(this._cards[i]) === true) {
                    return this._cards[i].pop();
                }
            }
            return null;
        }

        getHighestAvailableCardNoSpades() {
            let i = 1;
            for (i = 1; i < this._cards.length; i++) {
                if (this.containsAnAce(this._cards[i]) === true) {
                    return this._cards[i].pop();
                }
            }
            for (i = 1; i < this._cards.length; i++) {
                if (this.containsAKing(this._cards[i]) === true) {
                    return this._cards[i].pop();
                }
            }
            for (i = 1; i < this._cards.length; i++) {
                if (this.containsAQueen(this._cards[i]) === true) {
                    return this._cards[i].pop();
                }
            }
            return null;
        }

        getHighestAvailableSpade() {
            if (this.containsAnAce(this._cards[0]) === true) {
                return this._cards[0].pop();
            }
            if (this.containsAKing(this._cards[0]) === true) {
                return this._cards[0].pop();
            }
            if (this.containsAQueen(this._cards[0]) === true) {
                return this._cards[0].pop();
            }
            return null;
        }

        getLowestAvailableCard() {
            let lowest = this.getLowestAvailableCardNotASpade();
            if (lowest !== null) {
                return lowest;
            }
            if (this._cards[0].length > 0) {
                return this._cards[0].shift();
            }
            return null;
        }

        getLowestAvailableCardNotASpade() {
            if (this._cards[1].length > 0) {
                return this._cards[1].shift();
            }
            if (this._cards[2].length > 0) {
                return this._cards[2].shift();
            }
            if (this._cards[3].length > 0) {
                return this._cards[3].shift();
            }
            return null;
        }

        getLowestSpade() {
            if (this._cards[0].length > 0) {
                return this._cards[0].shift();
            }
            else {
                return null;
            }
        }

        getCardThatBeatsOrGoesLow() {
            let suitCards = this._cards[currentRoundSuit];
            if (suitCards.length === 0) {
                return null;
            }
            if (highestCurrentRoundCard._suit === Suit.Spade) {
                return suitCards.shift(); // Return lowest card
            }
            if (highestCurrentRoundCard._rank > suitCards[suitCards.length - 1]._rank) {
                return suitCards.shift(); // Return lowest card
            }
            else {
                return suitCards.pop(); // Return highest card
            }
        }

        sortByRank(suitList) {
            suitList.sort((a, b) => (a._rank > b._rank) ? 1 : -1);
        }

        getListString(suitList) {
            let result = "";
            let i = 0;
            for (i = 0; i < suitList.length; i++) {
                result += suitList[i].getString();
                if (i != suitList.length - 1) {
                    result += " ";
                }

            }
            return result;
        }

        clearBid() {
            this._bid = null;
        }

        setBid(bidAmount) {
            if (bidAmount < 0 || bidAmount > 13) {
                console.log("Bid amount was out of bounds: " + bidAmount);
            }
            else {
                this._bid = bidAmount;
                this._bidDiv.setInnerHtml(this._bid);
                this._tricksToBidsDiv.showBlock();
            }
        }

        determineBid() {
            let currentBid = 0;
            if (this._cards[Suit.Spade].length === 0) {
                // Check if I have any aces or face cards. If not, I probably want to bid nil this hand
                if (this.containsQueenOrHigher(this._cards[Suit.Heart]) === false && this.containsQueenOrHigher(this._cards[Suit.Diamond]) === false && this.containsQueenOrHigher(this._cards[Suit.Club]) === false) {
                    // bid nil
                    return currentBid;
                }
            }
            else {
                // If I have the ace of spades, that's a guaranteed trick.
                if (this.containsAnAce(this._cards[Suit.Spade]) === true) {
                    currentBid++;
                }
                if (this.containsAKing(this._cards[Suit.Spade]) === true) {
                    currentBid++;
                }
                if (this.containsAQueen(this._cards[Suit.Spade]) === true) {
                    currentBid++;
                }

                if (this._cards[Suit.Spade].length > 2) {
                    // If there are low counts of cards in one of these suits, spades will probably be useful there
                    if (this._cards[Suit.Heart].length < 3) {
                        currentBid++;
                    }
                    if (this._cards[Suit.Diamond].length < 3) {
                        currentBid++;
                    }
                    if (this._cards[Suit.Club].length < 3) {
                        currentBid++;
                    }
                }
                // If we have 5 spades, assume that we'll be able to get at least one more trick
                if (this._cards[0].length > 4) {
                    currentBid++;
                }
            }

            currentBid += this.getSuitBidCount(this._cards[Suit.Heart]);
            currentBid += this.getSuitBidCount(this._cards[Suit.Diamond]);
            currentBid += this.getSuitBidCount(this._cards[Suit.Club]);

            return currentBid;
        }

        getSuitBidCount(cardArray) {
            let currentBid = 0;
            if (cardArray.length < 5 && this.containsAnAce(cardArray) === true) {
                currentBid++;
            }
            if (cardArray.length < 3 && this.containsQueenOrKing(cardArray) === true) {
                currentBid++;
            }
            return currentBid;
        }

        containsAnAce(cardArray) {
            if (cardArray.find(card => card._rank === 14) !== undefined) {
                return true;
            }
            else {
                return false;
            }
        }

        containsAKing(cardArray) {
            if (cardArray.find(card => card._rank === 13) !== undefined) {
                return true;
            }
            else {
                return false;
            }
        }

        containsAQueen(cardArray) {
            if (cardArray.find(card => card._rank === 12) !== undefined) {
                return true;
            }
            else {
                return false;
            }
        }

        containsQueenOrKing(cardArray) {
            if (cardArray.find(card => card._rank === 12) !== undefined || cardArray.find(card => card._rank === 13) !== undefined) {
                return true;
            }
            else {
                return false;
            }
        }

        containsQueenOrHigher(cardArray) {
            let i = 0;
            for (i = 0; i < cardArray.length; i++) {
                if (cardArray[i]._rank > 11) {
                    return true;
                }
            }
            return false;
        }
    }

    // Functions
    function startGame() {
        // The Deck constructor should shuffle the cards, so no need to do it again here.
        deck = new Deck();
        player1 = new Player("Player1", true, "Player1");
        player2 = new Player("COM2", false, "Player2");
        player3 = new Player("COM3", false, "Player3");
        player4 = new Player("COM4", false, "Player4");
        players.push(player1);
        players.push(player2);
        players.push(player3);
        players.push(player4);
        dealerIndex = getRandomIntInclusive(0, 3);

        dealNewHand();

        Player1CardDiv = new HtmlDiv("Player1Card", "");
        Player2CardDiv = new HtmlDiv("Player2Card", "");
        Player3CardDiv = new HtmlDiv("Player3Card", "");
        Player4CardDiv = new HtmlDiv("Player4Card", "");
        PlayerBidInput = new HtmlInput("PlayerBidInput");
        PlayerBidContainerDiv = new HtmlDiv("PlayerBidContainer");
        Team1ScoreDiv = new HtmlDiv("Team1Score");
        Team2ScoreDiv = new HtmlDiv("Team2Score");

        setCurrentPlayerTurn(getNextPlayer(dealerIndex));
        initiateBidding();
    }

    function nextTurn() {
        setCurrentPlayerTurn(getNextPlayer(currentPlayerTurn));
    }

    function getNextPlayer(playerIndex) {
        var newIndex = playerIndex + 1;
        if (newIndex > 3) {
            newIndex = 0;
        }
        return newIndex;
    }

    function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function dealNewHand() {
        // It's not important to deal each card to every player in sequence since we know the cards in the deck are already random.
        deck = new Deck();
        player1.drawFullHand();
        player2.drawFullHand();
        player3.drawFullHand();
        player4.drawFullHand();

        // TODO: Maybe put this array initialization somewhere else to group it with other "reset" logic
        Player1CardsWithInputs = [];

        let player1HandArray = player1.getHandArray();

        let i = 0;
        for (i = 0; i < player1HandArray.length; i++) {
            let currentCard = player1HandArray[i];
            let htmlInput = new HtmlInput("playerCard" + i, currentCard.getString());
            if (currentCard._suit === Suit.Diamond || currentCard._suit === Suit.Heart) {
                htmlInput.setColorRed();
            }
            if (currentCard._suit === Suit.Club || currentCard._suit === Suit.Spade) {
                htmlInput.setColorBlack();
            }
            Player1CardsWithInputs.push(new CardWithHtmlInput(currentCard, htmlInput));
        }
    }

    function initiateBidding() {
        for (i = 0; i < 4; i++) {
            if (players[currentPlayerTurn]._isHuman) {
                break;
            }
            else {
                players[currentPlayerTurn].setBid(players[currentPlayerTurn].determineBid());
            }
            currentBidCount++;
            nextTurn();
        }
    }

    async function submitBid() {
        let playerBidValue = parseInt(PlayerBidInput.getValue(), 10);
        if (playerBidValue > -1 && playerBidValue < 14) {
            player1.setBid(playerBidValue);
            PlayerBidContainerDiv.hide();
            currentBidCount++;
            nextTurn();
            // Continue computer bidding if there is any more to do
            if (currentBidCount < 4) {
                while (currentBidCount < 4) {
                    players[currentPlayerTurn].setBid(players[currentPlayerTurn].determineBid());
                    currentBidCount++;
                    nextTurn();
                }
            }
            // Start gameplay
            console.log(player1);
            console.log(player2);
            console.log(player3);
            console.log(player4);

            let currentPlayer = players[currentPlayerTurn];
            if (currentPlayer._isHuman === false) {
                await currentPlayer.playCard(currentPlayer.findCardToPlay());
            }
        }
        else {
            console.log("Bad bid amount");
        }
    }

    async function selectCard(cardId) {
        // If bidding is still active, don't allow cards to be played
        if (currentPlayerTurn != 0 || currentBidCount < 4) {
            return;
        }
        let selectedCard = Player1CardsWithInputs[cardId]._card;
        if (currentRoundSuit === null && selectedCard._suit === Suit.Spade && spadesBrokenThisGame === false) {
            alert("Spades have not been broken this game!");
            return;
        }
        if (currentRoundSuit !== null && selectedCard._suit !== currentRoundSuit) {
            if (player1._cards[currentRoundSuit].length > 0) {
                alert("You must follow suit!");
                return;
            }
        }
        if (Player1CardsWithInputs !== null && Player1CardsWithInputs.length > cardId) {
            Player1CardsWithInputs[cardId]._htmlInput.hide();
            await player1.playCard(Player1CardsWithInputs[cardId]._card);
        }
    }

    function tallyCurrentRoundScore() {
        let player1and3Bid = player1._bid + player3._bid;
        let player2and4Bid = player2._bid + player4._bid;
        let player1and3Tricks = player1._tricksTaken + player3._tricksTaken;
        let player2and4Tricks = player2._tricksTaken + player4._tricksTaken;

        if (player1._bid === 0) {
            if (player1._bid === player1._tricksTaken) {
                Player1AndPlayer3Score += 100;
            }
            else {
                Player1AndPlayer3Score -= 100;
            }
        }

        if (player3._bid === 0) {
            if (player3._bid === player3._tricksTaken) {
                Player1AndPlayer3Score += 100;
            }
            else {
                Player1AndPlayer3Score -= 100;
            }
        }

        if (player1and3Bid > player1and3Tricks) {
            Player1AndPlayer3Score -= player1and3Bid * 10;
        }
        if (player1and3Bid <= player1and3Tricks) {
            Player1AndPlayer3Score += player1and3Bid * 10;
        }
        if (player1and3Bid < player1and3Tricks) {
            let sandbags = (player1and3Tricks - player1and3Bid);
            Player1AndPlayer3Sandbags += sandbags;
            if (Player1AndPlayer3Sandbags > 10) {
                Player1AndPlayer3Sandbags -= 10;
                Player1AndPlayer3Score -= 100;
            }

            Player1AndPlayer3Score += sandbags;
        }

        if (player2._bid === 0) {
            if (player2._bid === player2._tricksTaken) {
                Player2AndPlayer4Score += 100;
            }
            else {
                Player2AndPlayer4Score -= 100;
            }
        }

        if (player4._bid === 0) {
            if (player4._bid === player4._tricksTaken) {
                Player2AndPlayer4Score += 100;
            }
            else {
                Player2AndPlayer4Score -= 100;
            }
        }

        if (player2and4Bid > player2and4Tricks) {
            Player2AndPlayer4Score -= player2and4Bid * 10;
        }
        if (player2and4Bid <= player2and4Tricks) {
            Player2AndPlayer4Score += player2and4Bid * 10;
        }
        if (player2and4Bid < player2and4Tricks) {
            let sandbags = (player2and4Tricks - player2and4Bid);
            Player2AndPlayer4Sandbags += sandbags;
            if (Player2AndPlayer4Sandbags > 10) {
                Player2AndPlayer4Sandbags -= 10;
                Player2AndPlayer4Score -= 100;
            }
            Player2AndPlayer4Score += sandbags;
        }

        Team1ScoreDiv.setInnerHtml(Player1AndPlayer3Score);
        Team2ScoreDiv.setInnerHtml(Player2AndPlayer4Score);

        alert("Current game score: P1 and COM3: " + Player1AndPlayer3Score + " and COM2 and COM4: " + Player2AndPlayer4Score);
    }

    function clearPlayAreaCards() {
        Player1CardDiv.setInnerHtml('');
        Player2CardDiv.setInnerHtml('');
        Player3CardDiv.setInnerHtml('');
        Player4CardDiv.setInnerHtml('');
    }

    function setCurrentPlayerTurn(playerIndex) {
        players[0]._nameDiv.setColorWhite();
        players[1]._nameDiv.setColorWhite();
        players[2]._nameDiv.setColorWhite();
        players[3]._nameDiv.setColorWhite();
        currentPlayerTurn = playerIndex;
        players[playerIndex]._nameDiv.setColorGreen();
    }

    function startNewRound() {
        spadesBrokenThisGame = false;
        currentPlayedCards = [null, null, null, null];
        cardsPlayedThisRound = 0;
        highestCurrentRoundCard = null;
        totalHandsPlayed = 0;
        currentBidCount = 0;
        currentRoundSuit = null;
        PlayerBidInput.setValue("");
        PlayerBidContainerDiv.showBlock();
        let i = 0; 
        for (i = 0; i < players.length; i++) {
            players[i].resetBidAndTricks();
        }
        dealNewHand();
        dealerIndex = getNextPlayer(dealerIndex);
        setCurrentPlayerTurn(getNextPlayer(dealerIndex));
        initiateBidding();
    }

    function resetGame() {

    }

    function sleep(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }

    document.getElementById("playerCard0").addEventListener('click', function () { selectCard(0) });
    document.getElementById("playerCard1").addEventListener('click', function () { selectCard(1) });
    document.getElementById("playerCard2").addEventListener('click', function () { selectCard(2) });
    document.getElementById("playerCard3").addEventListener('click', function () { selectCard(3) });
    document.getElementById("playerCard4").addEventListener('click', function () { selectCard(4) });
    document.getElementById("playerCard5").addEventListener('click', function () { selectCard(5) });
    document.getElementById("playerCard6").addEventListener('click', function () { selectCard(6) });
    document.getElementById("playerCard7").addEventListener('click', function () { selectCard(7) });
    document.getElementById("playerCard8").addEventListener('click', function () { selectCard(8) });
    document.getElementById("playerCard9").addEventListener('click', function () { selectCard(9) });
    document.getElementById("playerCard10").addEventListener('click', function () { selectCard(10) });
    document.getElementById("playerCard11").addEventListener('click', function () { selectCard(11) });
    document.getElementById("playerCard12").addEventListener('click', function () { selectCard(12) });
    document.getElementById("PlayerBidSubmit").addEventListener('click', function () { submitBid() });

    // Main game:
    startGame();


</script>

</html>